# Leetcode解题分类
---

* 算法思想
    * 二分查找
        1. No.33
        2. No.34 分别二分查找范围的start和end
        3. No.81 去掉重复的元素，然后就和No.33一样了
        4. No.153
        5. No.162 对index做二分
        6. Mo.287 n+1个数，范围为a~(n-a+1)，在a~(n-a+1)范围内做二分
        7. No.378
    * 贪心思想
    * 2-pointer
        * 滑动窗口
            1. No.3 用flag存储窗口内元素出现的次数
            2. No.11 遍历容器的两条垂直边，每次移动较小的那一边
            3. No.209
        * 多数求和
            1. No.15 排序，遍历最大值，其余两值用2-pointer
            2. No.16 和No.15一样
            3. No.18 排序，遍历最大值和最小值，其余两值用2-pointer
    * 排序
        * 快速排序
            1. No.179 cmp(x, y)=-1 if str(x)+str(y)>str(y)+str(x) else 1
            2. No.274
            3. No.275 同No.274
        * 堆排序
            1. No.215 堆的大小为215，计算最大值用最小堆
            2. No.347
            3. No.373
        * 桶排序
            1. No.220 差不大于t，则桶的大小为t，和相邻的桶内元素比较即可
        * 计数排序
            1. No.75
    * 搜索
        * BFS
            1. No.102 层次遍历
            2. No.103 同No.102
            3. No.116 层次遍历
            4. No.117 同No.116
            5. No.127 按要求通过一系列转换从一个值变为另外一个值，可以将转换关系理解为图中的相连节点。
            6. No.130
            7. No.133 利用map存储新节点与对应源节点的映射，复制点与点之间的关系
            8. No.199
            9. No.200 计算有多少连通分量
            10. No.211
            11. No.222
            12. No.310 计算最长路径。从任一点a出发，找到离a最远的点b，再从b出发，找到离b最远的点c，搜索过程中记录下路径p。结果为p最中间的一个或两个点。
            13. No.331
        * DFS
            1. No.79
            2. No.94
            3. No.114 前序遍历
            4. No.113
            5. No.199
            6. No.230
            7. No.236 LCA问题
            8. No.310 计算最长路径。从任一点a出发，找到离a最远的点b，再从b出发，找到离b最远的点c，搜索过程中记录下b到c的路径p。结果为p最中间的一个或两个点。
            9. No.331
            10. No.332
        * Backtracking
            1. No.91
            2. No.93
            3. No.95 遍历当前树的根节点，分别生成左子树和右子树
            4. No.96 同No.95
            5. No.98 分别校验左右子树，然后校验左子树的最大值和右子树的最小值
            6. No.241
    * 分治
        1. No.95 遍历当前树的根节点，分别生成左子树和右子树
        2. No.96 同No.95
        3. No.98 分别校验左右子树，然后校验左子树的最大值和右子树的最小值
        4. No.105 已知前序中序构造树
        5. No.106 已知中序后序构造树
        6. No.109 每次都平分左右子树
        7. No.131
        8. No.148 归并排序
    * DP
        * 图DP
            * 路径数
                1. No.62
                2. No.63
            * 路径和
                1. No.64
                2. No.120 金字塔形结构，从底向上，逐层规约
        * 最长递增子序列(子串)
            1. No.300
        * 最长公共子序列(子串)
        * 最近公共祖先
            1. No.236
        * 0-1背包
        * 完全背包
            1. No.322
        * 树形DP
            1. No.337
        * 字符串编辑
        * 回文子序列(子串)
	        1. No.5
        * 整数分割
        * 字符串分割
            1. No.139
        * 状态机
            1. No.309 关键是初始值
        * 线性DP
            1. No.343 DP[i]代表n=i时的结果
            2. No.368 DP[i]代表以nums[i]结尾的序列，DP[i]=max([(*dp[j], n) for j in range(i - 1, -1, -1) if n % nums[j] == 0], key=lambda x: len(x), default=(n,)))
            3. No.376 要做两次DP，波动方向有两种
            4. No.377
        * 其他
		      1. No.152
		      2. No.213
		      3. No.221 DP数组中的DP[i][j]代表了以（i，j）为右下角的square的边长。所以当matrix[i][j]==1时，DP[i][j]=min(DP[i-1][j],DP[i][j-1],DP[i-1][j-1]),因为这三者中有一个为0时，matrix[i][j]并不能使某个square扩大。而这三者大于0，只能是其中最小值所在的square扩大。
		      4. No.264 丑数
		      5. No.279 满足条件的组合
              6. No.313 泛化丑数
              7. No.322
              8. No.375 **难**
    * 数学
        * 素数
        * 多数投票
            1. No.229 典型投票问题
        * 相遇问题
        * 排列组合
            1. No.17 生成组合
            2. No.22 生成排列
            3. No.31 计算排列组合中的下一个
            4. No.39 生成组合求和
            5. No.40 同No.39
            6. No.46 排列
            7. No.47 排列
            8. No.60 计算排列组合中的任意一个。以n为第一位数排列组合有(n-1)！种，且第一位越大则这个排列越大，以此类推。类似于动态进制。
            9. No.62 可以理解为变形的排列组合问题，所有Right和Down排列之后去除相对顺序错误的那些组合。
            10. No.77 组合
            11. No.78 同No.77
            12. No.90 同No.78
            13. No.216 组合
            14. No.357 不同的数即为首位不为0的组合数
        * 其他
            1. No.29 用减法模拟除法，用快速幂的方式加快速度
            2. No.50 快速幂
            3. No.166 模拟手工除法计算
            4. No.319 开关灯问题
            5. No.365 泊松分酒
            6. No.372 快速幂
    * 其他算法
        * Manacher算法
            1. No.5
* 数据结构
    * 字符串
        * 普通字符串操作
            1. No.8
            2. No.13
            3. No.49
            4. No.89 G(n)=['0'+G(n-1), '1'+reversed(G(n-1))]
            5. No.151
            6. No.165
            7. No187 长度固定，用hashmap找重复即可
            8. No.299
            9. No.306
            10. No.318
        * 字符串模拟大数运算
            1. No.43 按四位进行分块，加快运行速度
    * 链表
        * 快慢指针
            1. No.19
            2. No.142 一个指针一次走两步，一个一次走一步。
        * 普通链表操作
            1. No.2：链表操作模拟加法
            2. No.24
            3. No.61
            4. No.92
            5. No.138
            6. No.147 插入排序
            7. No.148 归并排序
            8. No.328
    * 位操作
        1. No.137 只有一个数字出现n次，其余数字均出现m次，m>n。用多个二进制位表示一个二进制位出现的次数，计算出推导式即可。
        2. No.201 除了m和n高位相同的部分，其余都为0
        3. No.260 两个数出现奇数次，其余都为偶数次。逐个异或获得m，找到m中最右的1，其余位置0，获得n。将n再次与所有数以此做与，按结果是否为0分成两组做异或，即得结果。
        4. No.338 二进制技巧
    * 栈
        1. No.71
        2. No.143
        3. No.150 逆波兰式
        4. No.173
        5. No.227
        6. No.341
    * 队列
    * 数组和矩阵
        * 普通数组和矩阵操作
            1. No.6
            2. No.36 分别校验行，列和块
            3. No.48 先将每列逆置，然后沿对角线做对称
            4. No.54 
            5. No.55
            6. No.56 按start排序
            7. No.59
            8. No.73
            9. No.74 从左下角或者右上角开始，类似于BST
            10. No.80
            11. No.82
            12. No.134 关键点在于如果车从i出发最远能到达j，那么从i到j出发都最远只能到达j，因为从i出发到达i+1至j中的任意一点时油量都>=0
            13. No.228
            14. No.238
            15. No.240 同No.74
            16. No.304 对每行做累和求差计算出范围的和
            17. No.307 累和求差计算出范围的和
            18. No.324
            19. No.334
    * 树
        * Trie树
            1. No.208
            2. No.211
        * 前中后序遍历
            1. No.114 前序遍历
            2. No.144 先序遍历
            3. No.230 中序排列
        * 摘叶算法
            1. No.310
    * 图
        * 并查集
            1. No.200 计算有多少连通分量
        * 涂色算法
        * 拓扑排序
            1. No.207 前驱问题，典型的拓扑排序类问题
            2. No.210 同207
