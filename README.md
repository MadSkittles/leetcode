# Leetcode解题分类
---
* 算法思想
    * 二分查找
        * 变形二分
            1. No.33
            2. No.34 分别二分查找范围的start和end
            3. No.81 去掉重复的元素，然后就和No.33一样了
            4. No.153
            5. No.162 对index做二分
    * 贪心思想
    * 2-pointer
        * 滑动窗口
            1. No.3 用flag存储窗口内元素出现的次数
            2. No.11 遍历容器的两条垂直边，每次移动较小的那一边
        * 多数求和
            1. No.15 排序，遍历最大值，其余两值用2-pointer
            2. No.16 和No.15一样
            3. No.18 排序，遍历最大值和最小值，其余两值用2-pointer
    * 排序
        * 快速排序
		1. No.179 cmp(x, y)=-1 if str(x)+str(y)>str(y)+str(x) else 1
        * 堆排序
        * 桶排序
        * 计数排序
            1. No.75
    * 搜索
        * BFS
            1. No.102 层次遍历
            2. No.103 同No.102
            3. No.116 层次遍历
            4. No.117 同No.116
            5. No.127 按要求通过一系列转换从一个值变为另外一个值，可以将转换关系理解为图中的相连节点。
            6. No.130
            7. No.133 利用map存储新节点与对应源节点的映射，复制点与点之间的关系
        * DFS
            1. No.79
            2. No.94
            3. No.114 前序遍历
            4. No.113
        * Backtracking
            1. No.91
            2. No.93
            3. No.95 遍历当前树的根节点，分别生成左子树和右子树
            4. No.96 同No.95
            5. No.98 分别校验左右子树，然后校验左子树的最大值和右子树的最小值
    * 分治
        1. No.95 遍历当前树的根节点，分别生成左子树和右子树
        2. No.96 同No.95
        3. No.98 分别校验左右子树，然后校验左子树的最大值和右子树的最小值
        4. No.105 已知前序中序构造树
        5. No.106 已知中序后序构造树
        6. No.109 每次都平分左右子树
        7. No.131
        8. No.148 归并排序
    * DP
        * 图DP
            * 路径数
                1. No.62
                2. No.63
            * 路径和
                1. No.64
                2. No.120 金字塔形结构，从底向上，逐层规约
        * 最长递增子序列(子串)
        * 最长公共子序列(子串)
        * 0-1背包
        * 完全背包
        * 树形DP
        * 字符串编辑
        * 回文子序列(子串)
	        1. No.5
        * 整数分割
        * 字符串分割
            1. No.139
        * 状态机
        * 其他
		1. No.152
    * 数学
        * 素数
        * 多数投票
        * 相遇问题
        * 排列组合
            1. No.17 生成组合
            2. No.22 生成排列
            3. No.31 计算排列组合中的下一个
            4. No.39 生成组合求和
            5. No.40 同No.39
            6. No.46 排列
            7. No.47 排列
            8. No.60 计算排列组合中的任意一个。以n为第一位数排列组合有(n-1)！种，且第一位越大则这个排列越大，以此类推。类似于动态进制。
            9. No.62 可以理解为变形的排列组合问题，所有Right和Down排列之后去除相对顺序错误的那些组合。
            10. No.77 组合
            11. No.78 同No.77
            12. No.90 同No.78
        * 其他
            1. No.29 用减法模拟除法，用快速幂的方式加快速度
            2. No.50 快速幂
            3. No.166 模拟手工除法计算
    * 其他算法
        * Manacher算法
            1. No.5
* 数据结构
    * 字符串
        * 普通字符串操作
            1. No.8
            2. No.13
            3. No.49
            4. No.89 G(n)=['0'+G(n-1), '1'+reversed(G(n-1))]
            5. No.151
            6. No.165
            7. No187 长度固定，用hashmap找重复即可
        * 字符串模拟大数运算
            1. No.43 按四位进行分块，加快运行速度
    * 链表
        * 快慢指针
            1. No.19
            2. No.142 一个指针一次走两步，一个一次走一步。
        * 普通链表操作
            1. No.2：链表操作模拟加法
            2. No.24
            3. No.61
            4. No.92
            5. No.138
            6. No.147 插入排序
            7. No.148 归并排序
    * 位操作
        1. No.137 只有一个数字出现n次，其余数字均出现m次，m>n。用多个二进制位表示一个二进制位出现的次数，计算出推导式即可。
    * 栈
        1. No.71
        2. No.143
        3. No.150 逆波兰式
        4. No.173
    * 队列
    * 数组和矩阵
        * 普通数组和矩阵操作
            1. No.6
            2. No.36 分别校验行，列和块
            3. No.48 先将每列逆置，然后沿对角线做对称
            4. No.54 
            5. No.55
            6. No.56 按start排序
            7. No.59
            8. No.73
            9. No.74 从左下角或者右上角开始，类似于BST
            10. No.80
            11. No.82
            12. No.134 关键点在于如果车从i出发最远能到达j，那么从i到j出发都最远只能到达j，因为从i出发到达i+1至j中的任意一点时油量都>=0
    * 树
        * Trie树
        * 前中后序遍历
            1. No.114 前序遍历
            2. No.144 先序遍历
    * 图
        * 并查集
        * 涂色算法        
        
